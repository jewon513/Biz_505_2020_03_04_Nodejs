# React 2020 프로젝트

## 2020-03-17

### React 프로젝트를 위한 nodejs 플러그인 설치

> - npm i -g yarn
> - yarn global add create-react-app
>
> > - 전역에서 사용하기 위해선 아래와 같은 명령어 입력
> > - yarn config set prefix C:\Users\jewon\AppData\Roaming\npm

### create-react-app (CRA)

> - webpack  
>   복잡하고 다양한 여러 dependency를 통합관리하고, deploy할 때 쉽게 할 수 있도록 도와주는 framework

## 새로운 react 프로젝트 생성

- reacte-react-app 프로젝트 명

### vsCode 확장 plug in

> - React Code Snippets : jsx 파일을 만드는 템플릿 제공 plug in
> - Prettier code formatter : 설치 후 설정에서 formatOnSave 검색하여 설정

## 2020-03-18

### react project build

> - yarn start 또는 npm start로 프로젝트를 시작하면 개발환경에서 소스코드를 변경한 후 저장을 하면 자동으로 웹 브라우저에 반영이 된다.
> - 하지만 이상태는 소스코드가 노출된 상태이고 최초 프로젝트를 시작할 때 상당히 많은 시간이 소요된다.
> - 보통 실제 사용환경에서는 소스코드를 Build하여 사용한다
> - yarn bulid 또는 npm build 명령을 입력하면 소스코드가 transfiler가 되어 프로젝트 시작이 빨리 된다.
> - yarn global add serve 명령으로 serve 툴을 설치하고 프로젝트 폴더에서 serve -s build 명령으로 실행을 한다.

### Class 방식의 component로 project를 진행

- 클래스 방식의 특징

  > - 자식 컴포넌트에 state, props 방식으로 데이터를 전달해 줄 수 있다.
  > - props 방식은 일방통행, state 방식은 역방향이 가능하다.
  > - LifeCycle 이라는 것이 지원이되서 프로젝트가 작동되는 것을 세부적으로 조정해서 만들 수 있다. (최적화 등을 수행할 수 있다.)

- 함수 방식의 특징

  > - 클래스 방식에 비해 코드가 간결한 면이 있다.
  > - 단 부모 컴포넌트로 부터 데이터를 받을때 기본적으로 props 방식으로만 받을 수 있다.
  > - Hooks라는 기능을 이용해서 조금 변형되게 사용할 수 있으나 클래스 방식에 비해 불편함이 있다

- LifeCycle

  > - 컴포넌트가 생성 -> render -> 컴포넌트가 소멸되는 동안 중간중간 작동되는 method들이 있는데, 이 method를 overried 하여 프로젝트 흐름을 세부적으로 조정할 수 있다.
  > - 데이터의 변화가 발생했을때 데이터변화 -> 변화감지 -> render -> 사용자에게 보여주기 -> 대기 상태 순으로 진행 되는 과정에서 중간중간에 작동되는 method 들이 있는데 이들을 세부적으로 조정할 수 있다.

- App.js를 클래스 타입 컴포넌트로 변환

  > - App.js에 연결되는(연동, 매핑) 하위 컴포넌트에서 데이터의 추가가 발생을 하고, 추가된 데이터에 연동되어 리스트를 표현해야하는 컴포넌트가 있다. 이럴때 일반적인 코딩에서는 하위 컴포넌트들끼리 데이터를 주고받으면서 기능을 수행하는데, React에서는 아주 특별한 경우가 아니면 그러한 패턴을 사용하지 않는다.
  > - 데이터를 추가하는 컴포넌트에서 데이터 추가가 이루어지면, 모든 데이터는 부모로부터 상속받은 데이터에 변화를 주고 데이터 리스트를 보여주는 컴포넌트에서는 부모 컴포넌트에서 render한 결과에 따라 보여주는 역할을 수행한다.
  > - 하위 컴포넌트는 view에 집중하는 역할만 수행하도록 하는 것이 좋은 패턴이다.

- 배열(일반배열, 객체)일 경우, 객체 릿흐트형일 경우 일부 데이터 변경
  > - 배열의 일부 요소값을 변경하는 시도를 하게 되면, 리엑트는 많은 양의 render 연산을 내부적으로 수행을 하게 된다.
  > - 원본 배열을 다른 배열로 잠시 복사하고, 복사본의 내용을 변경한 후 this.setState() 메서드에서 다시 원본배열에 덮어쓰는 코딩을 수행 하는 것이 효율이 좋다.
